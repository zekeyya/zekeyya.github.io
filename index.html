<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Permissions-Policy" content="clipboard-write=(self)">
<link rel="icon" type="image/png" href="Media/Favicon.Png">
<title>Zeke.Portfolio</title>
<style>
  html, body {
    margin:0;
    padding:0;
    width:100%;
    height:100%;
    overflow:hidden;
    cursor: url('cursor.png') 16 16, auto;
  }
  canvas {
    display:block;
    width:100%;
    height:100%;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script>
const c = document.getElementById("c");
const ctx = c.getContext("2d");

let cW = window.innerWidth;
let cH = window.innerHeight;
c.width = cW * devicePixelRatio;
c.height = cH * devicePixelRatio;
ctx.scale(devicePixelRatio, devicePixelRatio);

let bgColor = "#000000";
let animations = [];
let isHoveringText = false;

// Wave effect variables
const text = "Zeke.Portfolio";
const chars = text.split("");
const charOffsets = chars.map((_, i) => i * 0.11); // Delay per character (0.11s stagger)
const waveAmplitude = 7; // Half of 20px for wave effect
const wavePeriod = 2400; // 2.4s animation duration
const charScales = chars.map(() => ({ scale: 1 })); // Scale for pop animation

class Circle {
  constructor(opts){ Object.assign(this, opts); }
  draw(){
    ctx.globalAlpha = this.opacity || 1;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
    if(this.stroke){ ctx.strokeStyle=this.stroke.color; ctx.lineWidth=this.stroke.width; ctx.stroke(); }
    if(this.fill){ ctx.fillStyle=this.fill; ctx.fill(); }
    ctx.closePath();
    ctx.globalAlpha = 1;
  }
}

const colorPicker = (function(){
  const colors = ["#000000","#FFFFFF"];
  let index=0;
  return {
    next: ()=>{ index=(index+1)%colors.length; return colors[index]; },
    current: ()=>colors[index]
  };
})();

function removeAnimation(anim){ const i = animations.indexOf(anim); if(i>-1) animations.splice(i,1); }
function calcPageFillRadius(x,y){ return Math.sqrt(Math.pow(Math.max(x,cW-x),2)+Math.pow(Math.max(y,cH-y),2)); }

function handleEvent(e){
  let pageX, pageY;
  if(e.touches){ 
    e.preventDefault(); 
    pageX = e.touches[0].pageX;
    pageY = e.touches[0].pageY;
  } else {
    pageX = e.pageX || cW / 2;
    pageY = e.pageY || cH / 2;
  }
  const currentColor = colorPicker.current();
  const nextColor = colorPicker.next();
  const targetR = calcPageFillRadius(pageX, pageY);
  const rippleSize = Math.min(200, cW*0.4);

  // Page fill
  const pageFill = new Circle({x:pageX,y:pageY,r:0,fill:nextColor});
  const fillAnim = anime({
    targets: pageFill,
    r: targetR,
    duration: Math.max(targetR/2,750),
    easing:"easeOutQuart",
    complete: ()=>{ bgColor=pageFill.fill; removeAnimation(fillAnim); }
  });

  // Ripple
  const ripple = new Circle({x:pageX,y:pageY,r:0,fill:currentColor,stroke:{width:3,color:currentColor},opacity:1});
  const rippleAnim = anime({targets:ripple,r:rippleSize,opacity:0,duration:900,easing:"easeOutExpo",complete:removeAnimation});

  // Particles
  const particles = [];
  for(let i=0;i<32;i++) particles.push(new Circle({x:pageX,y:pageY,fill:currentColor,r:anime.random(24,48)}));
  const particlesAnim = anime({
    targets:particles,
    x:p=>p.x+anime.random(rippleSize,-rippleSize),
    y:p=>p.y+anime.random(rippleSize*1.15,-rippleSize*1.15),
    r:0,
    duration:anime.random(1000,1300),
    easing:"easeOutExpo",
    complete:removeAnimation
  });

  animations.push(fillAnim,rippleAnim,particlesAnim);
}

async function handleTextClick(e){
  let pageX = e.pageX || (e.touches && e.touches[0].pageX);
  let pageY = e.pageY || (e.touches && e.touches[0].pageY);
  
  // Check if click is within text bounds
  ctx.font = "24px Helvetica, Arial, sans-serif";
  const textWidth = ctx.measureText(text).width;
  const textHeight = 24;
  const textX = 20;
  const textY = 20;
  
  if(pageX >= textX && pageX <= textX + textWidth && 
     pageY >= textY - waveAmplitude && pageY <= textY + textHeight + waveAmplitude){
    e.preventDefault();
    
    // Check if we're in a secure context
    if (!window.isSecureContext) {
      console.error("Clipboard API unavailable: Not in a secure context (HTTPS required)");
      alert("Cannot copy link: This feature requires a secure (HTTPS) connection. Please copy manually: " + window.location.href);
      return false;
    }

    try {
      // Check clipboard permissions
      const permissionStatus = await navigator.permissions.query({ name: "clipboard-write" });
      if (permissionStatus.state === "granted" || permissionStatus.state === "prompt") {
        await navigator.clipboard.writeText(window.location.href);
        console.log("Pop animation triggered"); // Debug log
        // Trigger pop animation for each character
        charScales.forEach((target, i) => {
          anime({
            targets: target,
            scale: [1, 1.5, 1], // Pop in and out
            duration: 600,
            delay: i * 50, // Staggered delay for each character
            easing: "easeOutElastic(1, 0.6)"
          });
        });
      } else {
        throw new Error("Clipboard permission denied");
      }
    } catch (err) {
      console.error("Clipboard error:", err.message);
      alert("Failed to copy link: Clipboard access is blocked. Please copy manually: " + window.location.href);
    }
    return false; // Prevent ripple effect
  }
  return true; // Allow ripple effect
}

function handleMouseMove(e){
  let pageX = e.pageX || (e.touches && e.touches[0].pageX);
  let pageY = e.pageY || (e.touches && e.touches[0].pageY);
  
  // Check if cursor is within text bounds
  ctx.font = "24px Helvetica, Arial, sans-serif";
  const textWidth = ctx.measureText(text).width;
  const textHeight = 24;
  const textX = 20;
  const textY = 20;
  
  isHoveringText = (pageX >= textX && pageX <= textX + textWidth && 
                    pageY >= textY - waveAmplitude && pageY <= textY + textHeight + waveAmplitude);
  
  // Change cursor
  document.body.style.cursor = isHoveringText ? 'pointer' : "url('cursor.png') 16 16, auto";
}

document.addEventListener("mousemove", handleMouseMove);
document.addEventListener("touchmove", handleMouseMove);
document.addEventListener("mousedown", async (e) => {
  if (await handleTextClick(e)) {
    handleEvent(e);
  }
});
document.addEventListener("touchstart", async (e) => {
  if (await handleTextClick(e)) {
    handleEvent(e);
  }
});

// Trigger ripple effect automatically after 1.5 seconds
setTimeout(() => {
  handleEvent({}); // Simulate event with default center coordinates
}, 1500);

function animate(){
  const time = performance.now();

  ctx.fillStyle = bgColor;
  ctx.fillRect(0,0,cW,cH);

  // Draw ripples and page fill
  ctx.globalCompositeOperation = "source-over";
  animations.forEach(anim => anim.animatables.forEach(a => a.target.draw()));

  // Draw text with wave effect and scale
  ctx.font = "24px Helvetica, Arial, sans-serif";
  ctx.textBaseline = "top";
  ctx.globalCompositeOperation = "difference";
  ctx.fillStyle = "#ffffff";
  let currentX = 20;
  chars.forEach((char, i) => {
    const offsetY = Math.sin((time / wavePeriod + charOffsets[i]) * Math.PI * 2) * waveAmplitude;
    const scale = charScales[i].scale;
    ctx.save();
    ctx.translate(currentX, 20 + offsetY);
    ctx.scale(scale, scale);
    ctx.fillText(char, 0, 0);
    ctx.restore();
    currentX += ctx.measureText(char).width * scale;
  });

  ctx.globalCompositeOperation = "source-over";

  requestAnimationFrame(animate);
}
animate();

window.addEventListener("resize",()=>{
  cW = window.innerWidth;
  cH = window.innerHeight;
  c.width = cW*devicePixelRatio;
  c.height = cH*devicePixelRatio;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(devicePixelRatio,devicePixelRatio);
});
</script>
</body>
</html>